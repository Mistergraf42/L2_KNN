<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROCHE YILDIZ KPPV: sources/arbre.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROCHE YILDIZ KPPV
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_08d237fc27d4ecd563f71c5d52f2fecc.html">sources</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">arbre.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Fichier contenant les fonctions de gestion d'arbre.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;math.h&gt;</code><br />
<code>#include &quot;<a class="el" href="type_8h_source.html">../heads/type.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="zone_8h_source.html">../heads/zone.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aca1b15797e0f520765fb5006c7f6e5dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="type_8h.html#afcb23d336f41dc89cd6c4fcbeb8ec081">arbre_kd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arbre_8c.html#aca1b15797e0f520765fb5006c7f6e5dd">arbre_vide_kd</a> ()</td></tr>
<tr class="memdesc:aca1b15797e0f520765fb5006c7f6e5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permet de créer un arbre vide.  <br /></td></tr>
<tr class="separator:aca1b15797e0f520765fb5006c7f6e5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422c9dfb339212b1e854adf4b1d7afb1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arbre_8c.html#a422c9dfb339212b1e854adf4b1d7afb1">est_vide_arbre_kd</a> (<a class="el" href="type_8h.html#afcb23d336f41dc89cd6c4fcbeb8ec081">arbre_kd</a> a)</td></tr>
<tr class="memdesc:a422c9dfb339212b1e854adf4b1d7afb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permet de verifier si un arbre est vide.  <br /></td></tr>
<tr class="separator:a422c9dfb339212b1e854adf4b1d7afb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6a73ae30dbf9c4e222a307e37f926f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpoint.html">point</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arbre_8c.html#a3d6a73ae30dbf9c4e222a307e37f926f">creer_point</a> (int classe, float x, float y)</td></tr>
<tr class="memdesc:a3d6a73ae30dbf9c4e222a307e37f926f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cette fonction permet de crée un point.  <br /></td></tr>
<tr class="separator:a3d6a73ae30dbf9c4e222a307e37f926f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c488ffd3c99d38eacea999bd5d481c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="type_8h.html#afcb23d336f41dc89cd6c4fcbeb8ec081">arbre_kd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arbre_8c.html#a35c488ffd3c99d38eacea999bd5d481c">creer_arbre_kd</a> (<a class="el" href="structpoint.html">point</a> *p)</td></tr>
<tr class="memdesc:a35c488ffd3c99d38eacea999bd5d481c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permet de créer un arbre kd ayant pour valeur le point p.  <br /></td></tr>
<tr class="separator:a35c488ffd3c99d38eacea999bd5d481c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3c39f37ba6862e92d55b0d93659a92"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arbre_8c.html#a0d3c39f37ba6862e92d55b0d93659a92">compPoint</a> (<a class="el" href="structpoint.html">point</a> *p1, <a class="el" href="structpoint.html">point</a> *p2)</td></tr>
<tr class="memdesc:a0d3c39f37ba6862e92d55b0d93659a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction permettant de comparer deux points.  <br /></td></tr>
<tr class="separator:a0d3c39f37ba6862e92d55b0d93659a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af478a4e6ae910b846d4fb75b52b3364a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="type_8h.html#afcb23d336f41dc89cd6c4fcbeb8ec081">arbre_kd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arbre_8c.html#af478a4e6ae910b846d4fb75b52b3364a">inserer_aux</a> (<a class="el" href="type_8h.html#afcb23d336f41dc89cd6c4fcbeb8ec081">arbre_kd</a> a, <a class="el" href="structpoint.html">point</a> *p, int profondeur)</td></tr>
<tr class="memdesc:af478a4e6ae910b846d4fb75b52b3364a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction recursive permettant d'insérer un point dans un arbre kd, elle est appelée par la fonction inserer. Elle permet de parcourir l'arbre et de trouver la bonne place pour le point en fonction de sa valeur x et y.La profondeur de l'arbre est utilisé pour savoir si on doit comparer la valeur x ou y du point avec la valeur x ou y du noeud.  <br /></td></tr>
<tr class="separator:af478a4e6ae910b846d4fb75b52b3364a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f962fbbedd686a1277b7c0a7a14337"><td class="memItemLeft" align="right" valign="top"><a class="el" href="type_8h.html#afcb23d336f41dc89cd6c4fcbeb8ec081">arbre_kd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arbre_8c.html#a38f962fbbedd686a1277b7c0a7a14337">inserer</a> (<a class="el" href="type_8h.html#afcb23d336f41dc89cd6c4fcbeb8ec081">arbre_kd</a> a, <a class="el" href="structpoint.html">point</a> *p)</td></tr>
<tr class="memdesc:a38f962fbbedd686a1277b7c0a7a14337"><td class="mdescLeft">&#160;</td><td class="mdescRight">La fonction inserer fait appel à la fonction inserer_aux pour insérer un point dans un arbre kd, elle permet de verifier si l'arbre est vide et si c'est le cas elle crée un arbre kd avec le point p comme valeur. Sinon elle fait appel à la fonction inserer_aux. Elle definit une zone initial si l'arbre est vide.  <br /></td></tr>
<tr class="separator:a38f962fbbedd686a1277b7c0a7a14337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6525c6ff844b2445d4f4a8ff26682325"><td class="memItemLeft" align="right" valign="top"><a class="el" href="type_8h.html#afcb23d336f41dc89cd6c4fcbeb8ec081">arbre_kd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arbre_8c.html#a6525c6ff844b2445d4f4a8ff26682325">chargement_fich</a> (char *name, int *nb_noeud)</td></tr>
<tr class="memdesc:a6525c6ff844b2445d4f4a8ff26682325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elle permet de créer un arbre kd à partir d'un fichier. Elle lit le fichier et crée un point avec les valeurs lues. Elle crée un arbre kd avec le premier point lu et ensuite elle insère les autres points dans l'arbre kd.  <br /></td></tr>
<tr class="separator:a6525c6ff844b2445d4f4a8ff26682325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80adf00eab3b1245cab3c55985edbcf8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arbre_8c.html#a80adf00eab3b1245cab3c55985edbcf8">profondeur_noeud_kd</a> (<a class="el" href="type_8h.html#afcb23d336f41dc89cd6c4fcbeb8ec081">arbre_kd</a> a, <a class="el" href="structpoint.html">point</a> *val)</td></tr>
<tr class="memdesc:a80adf00eab3b1245cab3c55985edbcf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elle nous permet de connaître la profondeur de notre noeur dans l'arbre kd. Elle fait appel à elle même recursivement.  <br /></td></tr>
<tr class="separator:a80adf00eab3b1245cab3c55985edbcf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555feafd1cb291d72bc6cf29d85e99de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="type_8h.html#afcb23d336f41dc89cd6c4fcbeb8ec081">arbre_kd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arbre_8c.html#a555feafd1cb291d72bc6cf29d85e99de">supprimer</a> (<a class="el" href="type_8h.html#afcb23d336f41dc89cd6c4fcbeb8ec081">arbre_kd</a> a, <a class="el" href="structpoint.html">point</a> *p)</td></tr>
<tr class="memdesc:a555feafd1cb291d72bc6cf29d85e99de"><td class="mdescLeft">&#160;</td><td class="mdescRight">La fonction supprimer permet de supprimer un point de l'arbre kd. Elle fait appel à la fonction profondeur_noeud_kd pour connaître la profondeur du point dans l'arbre kd. Elle parcourt l'arbre kd jusqu'à trouver le point à supprimer. Elle fait appel à la fonction compPoint pour comparer le point courant avec le point à supprimer. Si le point est trouvé elle le supprime et retourne l'arbre kd. Sinon elle affiche un message d'erreur.  <br /></td></tr>
<tr class="separator:a555feafd1cb291d72bc6cf29d85e99de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79062c394fde9afb58b2eaaa7d7520f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arbre_8c.html#a79062c394fde9afb58b2eaaa7d7520f5">estfeuille_kd</a> (<a class="el" href="type_8h.html#afcb23d336f41dc89cd6c4fcbeb8ec081">arbre_kd</a> a)</td></tr>
<tr class="memdesc:a79062c394fde9afb58b2eaaa7d7520f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permet de savoir si un noeud est une feuille.  <br /></td></tr>
<tr class="separator:a79062c394fde9afb58b2eaaa7d7520f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f15b7938b9c28e93bddb957a4ae2ece"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpoint.html">point</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arbre_8c.html#a7f15b7938b9c28e93bddb957a4ae2ece">rechercher_aux</a> (<a class="el" href="type_8h.html#afcb23d336f41dc89cd6c4fcbeb8ec081">arbre_kd</a> a, <a class="el" href="structpoint.html">point</a> *p, <a class="el" href="structpoint.html">point</a> *ppv, int k, int profondeur)</td></tr>
<tr class="memdesc:a7f15b7938b9c28e93bddb957a4ae2ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">La fonction rechecher_aux est la plus complexe de la partie arbre, elle utilise les axes pour parcourir l'arbre kd et trouver les plus proches voisins. Elle fait appel à la fonction maj_liste pour mettre à jour la liste des plus proches voisins. Elle fait appel à elle même recursivement pour voir si dans un sous arbre il n'y a pas de plus proche voisin. Elle compare la distance entre le point et le plus proche voisin avec la distance entre le point et l'axe pour savoir si elle doit parcourir le sous arbre gauche ou droit.  <br /></td></tr>
<tr class="separator:a7f15b7938b9c28e93bddb957a4ae2ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779872743aec5f548c6096ea7ecb42e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpoint.html">point</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arbre_8c.html#a779872743aec5f548c6096ea7ecb42e8">rechercher</a> (<a class="el" href="type_8h.html#afcb23d336f41dc89cd6c4fcbeb8ec081">arbre_kd</a> a, <a class="el" href="structpoint.html">point</a> *p, int k)</td></tr>
<tr class="memdesc:a779872743aec5f548c6096ea7ecb42e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction permettant de trouver les voisins les plus proches du point p. Elle fait appel à la fonction rechercher_aux. Elle crée une liste de k points et la retourne.  <br /></td></tr>
<tr class="separator:a779872743aec5f548c6096ea7ecb42e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Fichier contenant les fonctions de gestion d'arbre. </p>
<dl class="section author"><dt>Author</dt><dd>ANAIS ROCHE - YILDIZ TOLGA </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.1 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2023-05-19</dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (c) 2023 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aca1b15797e0f520765fb5006c7f6e5dd" name="aca1b15797e0f520765fb5006c7f6e5dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca1b15797e0f520765fb5006c7f6e5dd">&#9670;&#160;</a></span>arbre_vide_kd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="type_8h.html#afcb23d336f41dc89cd6c4fcbeb8ec081">arbre_kd</a> arbre_vide_kd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permet de créer un arbre vide. </p>
<dl class="section return"><dt>Returns</dt><dd>arbre_kd </dd></dl>

</div>
</div>
<a id="a6525c6ff844b2445d4f4a8ff26682325" name="a6525c6ff844b2445d4f4a8ff26682325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6525c6ff844b2445d4f4a8ff26682325">&#9670;&#160;</a></span>chargement_fich()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="type_8h.html#afcb23d336f41dc89cd6c4fcbeb8ec081">arbre_kd</a> chargement_fich </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nb_noeud</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elle permet de créer un arbre kd à partir d'un fichier. Elle lit le fichier et crée un point avec les valeurs lues. Elle crée un arbre kd avec le premier point lu et ensuite elle insère les autres points dans l'arbre kd. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>nom du fichier </td></tr>
    <tr><td class="paramname">nb_noeud</td><td>nombre de noeud dans le fichier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arbre_kd </dd></dl>

</div>
</div>
<a id="a0d3c39f37ba6862e92d55b0d93659a92" name="a0d3c39f37ba6862e92d55b0d93659a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d3c39f37ba6862e92d55b0d93659a92">&#9670;&#160;</a></span>compPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int compPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoint.html">point</a> *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint.html">point</a> *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction permettant de comparer deux points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>premier point </td></tr>
    <tr><td class="paramname">p2</td><td>deuxième point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="a35c488ffd3c99d38eacea999bd5d481c" name="a35c488ffd3c99d38eacea999bd5d481c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c488ffd3c99d38eacea999bd5d481c">&#9670;&#160;</a></span>creer_arbre_kd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="type_8h.html#afcb23d336f41dc89cd6c4fcbeb8ec081">arbre_kd</a> creer_arbre_kd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoint.html">point</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permet de créer un arbre kd ayant pour valeur le point p. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>le points qui sera la valeur du noeud </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arbre_kd </dd></dl>

</div>
</div>
<a id="a3d6a73ae30dbf9c4e222a307e37f926f" name="a3d6a73ae30dbf9c4e222a307e37f926f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6a73ae30dbf9c4e222a307e37f926f">&#9670;&#160;</a></span>creer_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpoint.html">point</a> * creer_point </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>classe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cette fonction permet de crée un point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">classe</td><td>la classe du point </td></tr>
    <tr><td class="paramname">x</td><td>ça coordonnée x </td></tr>
    <tr><td class="paramname">y</td><td>ça coordonnée y </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>point* </dd></dl>

</div>
</div>
<a id="a422c9dfb339212b1e854adf4b1d7afb1" name="a422c9dfb339212b1e854adf4b1d7afb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422c9dfb339212b1e854adf4b1d7afb1">&#9670;&#160;</a></span>est_vide_arbre_kd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int est_vide_arbre_kd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="type_8h.html#afcb23d336f41dc89cd6c4fcbeb8ec081">arbre_kd</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permet de verifier si un arbre est vide. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>qui est un arbre </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="a79062c394fde9afb58b2eaaa7d7520f5" name="a79062c394fde9afb58b2eaaa7d7520f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79062c394fde9afb58b2eaaa7d7520f5">&#9670;&#160;</a></span>estfeuille_kd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int estfeuille_kd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="type_8h.html#afcb23d336f41dc89cd6c4fcbeb8ec081">arbre_kd</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permet de savoir si un noeud est une feuille. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>arbre kd </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="a38f962fbbedd686a1277b7c0a7a14337" name="a38f962fbbedd686a1277b7c0a7a14337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f962fbbedd686a1277b7c0a7a14337">&#9670;&#160;</a></span>inserer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="type_8h.html#afcb23d336f41dc89cd6c4fcbeb8ec081">arbre_kd</a> inserer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="type_8h.html#afcb23d336f41dc89cd6c4fcbeb8ec081">arbre_kd</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint.html">point</a> *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>La fonction inserer fait appel à la fonction inserer_aux pour insérer un point dans un arbre kd, elle permet de verifier si l'arbre est vide et si c'est le cas elle crée un arbre kd avec le point p comme valeur. Sinon elle fait appel à la fonction inserer_aux. Elle definit une zone initial si l'arbre est vide. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>arbre où nous voullons insérer le point </td></tr>
    <tr><td class="paramname">p</td><td>le point que nous voulons insérer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arbre_kd </dd></dl>

</div>
</div>
<a id="af478a4e6ae910b846d4fb75b52b3364a" name="af478a4e6ae910b846d4fb75b52b3364a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af478a4e6ae910b846d4fb75b52b3364a">&#9670;&#160;</a></span>inserer_aux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="type_8h.html#afcb23d336f41dc89cd6c4fcbeb8ec081">arbre_kd</a> inserer_aux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="type_8h.html#afcb23d336f41dc89cd6c4fcbeb8ec081">arbre_kd</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint.html">point</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>profondeur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction recursive permettant d'insérer un point dans un arbre kd, elle est appelée par la fonction inserer. Elle permet de parcourir l'arbre et de trouver la bonne place pour le point en fonction de sa valeur x et y.La profondeur de l'arbre est utilisé pour savoir si on doit comparer la valeur x ou y du point avec la valeur x ou y du noeud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>arbre kd où nous allons insérer le point </td></tr>
    <tr><td class="paramname">p</td><td>le point que nous voulons insérer </td></tr>
    <tr><td class="paramname">profondeur</td><td>la profondeur de l'arbre </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arbre_kd </dd></dl>

</div>
</div>
<a id="a80adf00eab3b1245cab3c55985edbcf8" name="a80adf00eab3b1245cab3c55985edbcf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80adf00eab3b1245cab3c55985edbcf8">&#9670;&#160;</a></span>profondeur_noeud_kd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int profondeur_noeud_kd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="type_8h.html#afcb23d336f41dc89cd6c4fcbeb8ec081">arbre_kd</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint.html">point</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elle nous permet de connaître la profondeur de notre noeur dans l'arbre kd. Elle fait appel à elle même recursivement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>arbre kd </td></tr>
    <tr><td class="paramname">val</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="a779872743aec5f548c6096ea7ecb42e8" name="a779872743aec5f548c6096ea7ecb42e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779872743aec5f548c6096ea7ecb42e8">&#9670;&#160;</a></span>rechercher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpoint.html">point</a> * rechercher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="type_8h.html#afcb23d336f41dc89cd6c4fcbeb8ec081">arbre_kd</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint.html">point</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction permettant de trouver les voisins les plus proches du point p. Elle fait appel à la fonction rechercher_aux. Elle crée une liste de k points et la retourne. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>l'arbre kd où nous cherchons les plus proches voisins </td></tr>
    <tr><td class="paramname">p</td><td>le point dont nous voulons connaître les plus proches voisins </td></tr>
    <tr><td class="paramname">k</td><td>nombre de voisins voulus par l'utilisateur </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>point* </dd></dl>

</div>
</div>
<a id="a7f15b7938b9c28e93bddb957a4ae2ece" name="a7f15b7938b9c28e93bddb957a4ae2ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f15b7938b9c28e93bddb957a4ae2ece">&#9670;&#160;</a></span>rechercher_aux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpoint.html">point</a> * rechercher_aux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="type_8h.html#afcb23d336f41dc89cd6c4fcbeb8ec081">arbre_kd</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint.html">point</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint.html">point</a> *&#160;</td>
          <td class="paramname"><em>ppv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>profondeur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>La fonction rechecher_aux est la plus complexe de la partie arbre, elle utilise les axes pour parcourir l'arbre kd et trouver les plus proches voisins. Elle fait appel à la fonction maj_liste pour mettre à jour la liste des plus proches voisins. Elle fait appel à elle même recursivement pour voir si dans un sous arbre il n'y a pas de plus proche voisin. Elle compare la distance entre le point et le plus proche voisin avec la distance entre le point et l'axe pour savoir si elle doit parcourir le sous arbre gauche ou droit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>l'arbre kd où nous cherchons les plus proches voisins </td></tr>
    <tr><td class="paramname">p</td><td>le point dont nous voulons connaître les plus proches voisins </td></tr>
    <tr><td class="paramname">ppv</td><td>la liste temporaire des plus proches voisins et qui sera la liste finale </td></tr>
    <tr><td class="paramname">k</td><td>nombre de k plus proches voisins voulus par l'utilisateur </td></tr>
    <tr><td class="paramname">profondeur</td><td>la profondeur de l'arbre kd </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>point* </dd></dl>

</div>
</div>
<a id="a555feafd1cb291d72bc6cf29d85e99de" name="a555feafd1cb291d72bc6cf29d85e99de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a555feafd1cb291d72bc6cf29d85e99de">&#9670;&#160;</a></span>supprimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="type_8h.html#afcb23d336f41dc89cd6c4fcbeb8ec081">arbre_kd</a> supprimer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="type_8h.html#afcb23d336f41dc89cd6c4fcbeb8ec081">arbre_kd</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint.html">point</a> *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>La fonction supprimer permet de supprimer un point de l'arbre kd. Elle fait appel à la fonction profondeur_noeud_kd pour connaître la profondeur du point dans l'arbre kd. Elle parcourt l'arbre kd jusqu'à trouver le point à supprimer. Elle fait appel à la fonction compPoint pour comparer le point courant avec le point à supprimer. Si le point est trouvé elle le supprime et retourne l'arbre kd. Sinon elle affiche un message d'erreur. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>arbre kd </td></tr>
    <tr><td class="paramname">p</td><td>point à supprimer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arbre_kd </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
